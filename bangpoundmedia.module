<?php
/**
 * @file
 * Code for the bangpoundmedia feature.
 */

/**
 * Implementation of hook_module_implements_alter().
 */
function bangpoundmedia_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'media_wysiwyg_token_to_markup_alter') {
    $group = $implementations['bangpoundmedia'];
    unset($implementations['bangpoundmedia']);
    $implementations['bangpoundmedia'] = $group;
  }
}

/**
 * Implementation of hook_filter_info_alter()
 */
function bangpoundmedia_filter_info_alter(&$info) {
  if ($info['media_filter']['process callback'] == 'media_wysiwyg_filter') {
    $info['media_filter']['process callback'] = 'bangpoundmedia_filter';
  }
}


/**
 * Filter callback for media markup filter.
 *
 * Replaces Media filter tags with inline macro which is decoded when entity is viewed.
 */
function bangpoundmedia_filter($text) {
  $text = preg_replace_callback(MEDIA_WYSIWYG_TOKEN_REGEX, 'bangpoundmedia_token_to_inline', $text);
  return $text;
}

/**
 * Implement hook_preprocess_file_entity().
 */
function bangpoundmedia_preprocess_file_entity(&$variables) {
  $elements = $variables['elements'];
  if (isset($elements['#media_filter'])) {
    $variables['attributes_array'] = array_merge($variables['attributes_array'], $elements['#attributes']);
    if (isset($variables['attributes_array']['style'])) {
      $variables['attributes_array']['style'] = preg_replace('|height: ?.+?\;|', '', $variables['attributes_array']['style']);
    }
    if (!isset($elements['#attributes']['class'])) {
      $elements['#attributes']['class'] = array();
    }
    else if (!is_array($elements['#attributes']['class'])) {
      $elements['#attributes']['class'] = explode(' ', $elements['#attributes']['class']);
    }
    $variables['classes_array'] = array_merge($variables['classes_array'], $elements['#attributes']['class']);
  }
}

/**
 * Implement file_formatter_info_alter().
 */
function bangpoundmedia_file_formatter_info_alter(&$info) {

  if (isset($info['file_field_mediaelement_video'])) {
    $info['file_field_mediaelement_video']['file types'][] = 'video';
  }

  if (isset($info['file_field_mediaelement_audio'])) {
    $info['file_field_mediaelement_audio']['file types'][] = 'audio';
  }
}

/**
 * Implements hook_ctools_plugin_api().
 */
function bangpoundmedia_ctools_plugin_api($module, $api) {
  if ($module == 'file_entity' && $api == 'file_default_displays') {
    return array('version' => 1);
  }
}

/**
 * Implement hook_form_FORMID_alter().
 *
 * This hides the large filetype icon formatter on preview view modes because it is always
 * enabled.
 *
 * @see bangpoundmedia_file_displays_alter().
 */
function bangpoundmedia_form_file_entity_file_display_form_alter(&$form, &$form_state) {
  $file_type = $form_state['build_info']['args'][0]->type;
  $view_mode = $form_state['build_info']['args'][1];

  if ($view_mode == 'preview') {
    unset($form['displays']['status']['file_field_media_large_icon']);
    unset($form['displays']['order']['file_field_media_large_icon']);
  }

  $current_displays = file_displays_load($file_type, $view_mode, TRUE);
  foreach ($current_displays as $name => $display) {
    $current_displays[$name] = (array) $display;
  }

  $formatters = file_info_formatter_types();
  $formatter_types = array('file_field_mediaelement_video', 'file_field_mediaelement_audio');
  $types = array_intersect($formatter_types, array_keys($form['displays']['settings']));
  if (!empty($types)) {
    $visible_steam_wrappers = file_get_stream_wrappers(STREAM_WRAPPERS_READ_VISIBLE);
    $options = array();
    foreach ($visible_steam_wrappers as $scheme => $information) {
      $options[$scheme] = check_plain($information['name']);
    }
    foreach ($formatter_types as $name) {

      $defaults = !empty($formatters[$name]['default settings']) ? $formatters[$name]['default settings'] : array();
      $settings = !empty($current_displays[$name]['settings']) ? $current_displays[$name]['settings'] : array();
      $settings += $defaults;

      if (isset($form['displays']['settings'][$name])) {
        $form['displays']['settings'][$name]['allowed_schemes'] = array(
          '#type' => 'checkboxes',
          '#title' => t('Allowed URI schemes'),
          '#options' => $options,
          '#default_value' => isset($settings['allowed_schemes']) ? $settings['allowed_schemes'] : array(),
          '#description' => t('URI schemes include public:// and private:// which are the Drupal files directories, and may also refer to remote sites.'),
          '#weight' => 2,
        );
      }
    }
  }
}

/**
 * Implements hook_wysiwyg_editor_settings_alter().
 *
 * @param array $settings
 * @param array $context
 */
function bangpoundmedia_wysiwyg_editor_settings_alter(&$settings, $context) {

  // Style sets are a feature of CKEditor.
  if ($context['profile']->editor == 'ckeditor') {

    // Add these styles only to profiles whose format uses the media filter.
    if (isset($context['profile']->format)) {

      // Load all filter configurations for this format.
      $filters = filter_list_format($context['profile']->format);
      if ($filters && array_key_exists('media_filter', $filters)) {
        if ($filters['media_filter']->status != 0) {

          // The media-element class attribute value must be added to every style to
          // prevent the media filter from detaching from the WYSIWYG images it uses
          // as placeholders.

          // Left alignment style.
          $settings['stylesSet'][] = array(
            'name' => 'Media left',
            'element' => 'img',
            'attributes' => array(
              'align' => 'left',
            ),
          );

          // Right alignment style.
          $settings['stylesSet'][] = array(
            'name' => 'Media right',
            'element' => 'img',
            'attributes' => array(
              'align' => 'right',
            ),
          );

          // Stylesheet with those styles defined as minimally as possible
          // so they work reliably in the WYSIWYG editor and when viewing
          // content.
          $css = drupal_get_path('module', 'bangpoundmedia') .'/bangpoundmedia.css';
          $settings['contentsCss'][] = url($css);
        }
      }
    }
  }
}

/**
 * Comes after IMCE's normal process function.
 */
function bangpoundmedia_imce_process(&$imce) {
  $imce['perm']['upload'] = FALSE;
  $imce['perm']['thumb'] = FALSE;
  $imce['perm']['delete'] = FALSE;
  $imce['perm']['resize'] = FALSE;
}

/**
 * For managed files, attach a media item to the table row.
 */
function bangpoundmedia_imce_scan_directory($dirname, $imce) {
  $directory = imce_scan_directory($dirname, $imce);
  $prefix = 'public://'. $dirname;
  foreach ($directory['files'] as &$file) {
    $obj = file_uri_to_object($prefix .'/'. $file['name']);
    media_browser_build_media_item($obj);
    if (isset($obj->fid)) {
      $file['fid'] = $obj->fid;
      $file['media_item'] = $obj;
    }
  }
  return $directory;
}

/**
 * Encodes Media filter tag as inline macro.
 */
function bangpoundmedia_token_to_inline($match) {
  $tag = $match[0];

  // Using the serialize method on the parser causes
  // `Fatal error:  Class 'MediaFilterMacro' not found`
  // because __FUNCTION__ may be called before bootstrap is complete.

  $macro_params = array();
  $macro_params[] = 'media_filter';
  $macro_params[] = 'tag='. base64_encode($tag);
  $output = '[' . implode('|', $macro_params) . ']';
  return $output;
}

/**
 * Implements hook_inline_info().
 */
function bangpoundmedia_inline_info() {
  $info['media_filter'] = array(
    'class' => 'Drupal\bangpoundmedia\MediaFilterMacro',
  );
  return $info;
}
