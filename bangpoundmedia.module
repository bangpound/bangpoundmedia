<?php
/**
 * @file
 * Code for the bangpoundmedia feature.
 */

/**
 * Implementation of hook_module_implements_alter().
 */
function bangpoundmedia_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'media_token_to_markup_alter') {
    $group = $implementations['bangpoundmedia'];
    unset($implementations['bangpoundmedia']);
    $implementations['bangpoundmedia'] = $group;
  }
}

/**
 * Implementation of hook_filter_info_alter()
 */
function bangpoundmedia_filter_info_alter(&$info) {
  $info['media_filter']['process callback'] = 'bangpoundmedia_filter';
}


/**
 * Filter callback for media markup filter.
 *
 * Replaces Media filter tags with inline macro which is decoded when entity is viewed.
 */
function bangpoundmedia_filter($text) {
  $text = preg_replace_callback(MEDIA_TOKEN_REGEX, 'bangpoundmedia_token_to_inline', $text);
  return $text;
}

/**
 * Implement hook_preprocess_file_entity().
 */
function bangpoundmedia_preprocess_file_entity(&$variables) {
  $elements = $variables['elements'];
  if (isset($elements['#media_filter'])) {
    $variables['attributes_array'] = array_merge($variables['attributes_array'], $elements['#attributes']);
    if (isset($variables['attributes_array']['style'])) {
      $variables['attributes_array']['style'] = preg_replace('|height: ?.+?\;|', '', $variables['attributes_array']['style']);
    }
    if (!isset($elements['#attributes']['class'])) {
      $elements['#attributes']['class'] = array();
    }
    else if (!is_array($elements['#attributes']['class'])) {
      $elements['#attributes']['class'] = explode(' ', $elements['#attributes']['class']);
    }
    $variables['classes_array'] = array_merge($variables['classes_array'], $elements['#attributes']['class']);
  }
}

/**
 * Implement file_formatter_info_alter().
 */
function bangpoundmedia_file_formatter_info_alter(&$info) {

  // Remove the core Image formatter because File Entity module provides a better one.
  if (isset($info['file_image']) && isset($info['file_field_image'])) {
    unset($info['file_field_image']);
  }

  // The table formatter is useful for file fields with multiple values, but it is not
  // as useful for the file display because this is always a single value.
  if (isset($info['file_field_file_table'])) {
    unset($info['file_field_file_table']);
  }

  // Rendered file formatter is not useful for file displays.
  if (isset($info['file_field_file_rendered'])) {
    unset($info['file_field_file_rendered']);
  }

  if (isset($info['file_field_file_default'])) {
    $info['file_field_file_default']['description'] = t('An icon and the filename.');
  }

  if (isset($info['file_field_file_url_plain'])) {
    $info['file_field_file_url_plain']['description'] = t('Plain text URL.');
  }

  if (isset($info['file_field_media_large_icon'])) {
    $info['file_field_media_large_icon']['description'] = t('Reliable fallback for the <em>preview</em> view mode.');
  }

  if (isset($info['file_field_mediaelement_video'])) {
    $info['file_field_mediaelement_video']['file types'][] = 'video';
  }

  if (isset($info['file_field_mediaelement_audio'])) {
    $info['file_field_mediaelement_audio']['file types'][] = 'audio';
  }
}

/**
 * Implements hook_ctools_plugin_api().
 */
function bangpoundmedia_ctools_plugin_api($module, $api) {
  if ($module == 'file_entity' && $api == 'file_default_displays') {
    return array('version' => 1);
  }
}

/**
 * Implement hook_form_FORMID_alter().
 *
 * This hides the large filetype icon formatter on preview view modes because it is always
 * enabled.
 *
 * @see bangpoundmedia_file_displays_alter().
 */
function bangpoundmedia_form_file_entity_file_display_form_alter(&$form, &$form_state) {
  $view_mode = $form_state['build_info']['args'][1];
  if ($view_mode == 'preview') {
    unset($form['displays']['status']['file_field_media_large_icon']);
    unset($form['displays']['order']['file_field_media_large_icon']);
  }
}

/**
 * Implements hook_wysiwyg_editor_settings_alter().
 *
 * @param type $settings
 * @param type $context
 */
function bangpoundmedia_wysiwyg_editor_settings_alter(&$settings, $context) {

  // Style sets are a feature of CKEditor.
  if ($context['profile']->editor == 'ckeditor') {

    // Add these styles only to profiles whose format uses the media filter.
    if (isset($context['profile']->format)) {

      // Load all filter configurations for this format.
      $filters = filter_list_format($context['profile']->format);
      if ($filters && array_key_exists('media_filter', $filters)) {
        if ($filters['media_filter']->status != 0) {

          // The media-element class attribute value must be added to every style to
          // prevent the media filter from detaching from the WYSIWYG images it uses
          // as placeholders.

          // Left alignment style.
          $settings['stylesSet'][] = array(
            'name' => 'Media left',
            'element' => 'img',
            'attributes' => array(
              'align' => 'left',
            ),
          );

          // Right alignment style.
          $settings['stylesSet'][] = array(
            'name' => 'Media right',
            'element' => 'img',
            'attributes' => array(
              'align' => 'right',
            ),
          );

          // Stylesheet with those styles defined as minimally as possible
          // so they work reliably in the WYSIWYG editor and when viewing
          // content.
          $css = drupal_get_path('module', 'bangpoundmedia') .'/bangpoundmedia.css';
          $settings['contentsCss'][] = url($css);
        }
      }
    }
  }
}

/**
 * Comes after IMCE's normal process function.
 */
function bangpoundmedia_imce_process(&$imce) {
  $imce['perm']['upload'] = FALSE;
  $imce['perm']['thumb'] = FALSE;
  $imce['perm']['delete'] = FALSE;
  $imce['perm']['resize'] = FALSE;
}

/**
 * For managed files, attach a media item to the table row.
 */
function bangpoundmedia_imce_scan_directory($dirname, $imce) {
  $directory = imce_scan_directory($dirname, $imce);
  $prefix = 'public://'. $dirname;
  foreach ($directory['files'] as &$file) {
    $obj = file_uri_to_object($prefix .'/'. $file['name']);
    media_browser_build_media_item($obj);
    if (isset($obj->fid)) {
      $file['fid'] = $obj->fid;
      $file['media_item'] = $obj;
    }
  }
  return $directory;
}

/**
 * Encodes Media filter tag as inline macro.
 */
function bangpoundmedia_token_to_inline($match) {
  $tag = $match[0];

  // Using the serialize method on the parser causes
  // `Fatal error:  Class 'MediaFilterMacro' not found`
  // because __FUNCTION__ may be called before bootstrap is complete.

  $macro_params = array();
  $macro_params[] = 'media_filter';
  $macro_params[] = 'tag='. base64_encode($tag);
  $output = '[' . implode('|', $macro_params) . ']';
  return $output;
}

/**
 * Implements hook_inline_info().
 */
function bangpoundmedia_inline_info() {
  $info['media_filter'] = array(
    'class' => 'Drupal\bangpoundmedia\MediaFilterMacro',
  );
  return $info;
}
